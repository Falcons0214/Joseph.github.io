"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[670],{4089:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"FreeRTOS/Multi-core Message Buffer","title":"Multi-core Message Buffer","description":"Brief","source":"@site/docs/FreeRTOS/Multi-core Message Buffer.md","sourceDirName":"FreeRTOS","slug":"/FreeRTOS/Multi-core Message Buffer","permalink":"/Joseph.github.io/docs/FreeRTOS/Multi-core Message Buffer","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/FreeRTOS/Multi-core Message Buffer.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Initialization Macro","permalink":"/Joseph.github.io/docs/FreeRTOS/Initialization Macro"},"next":{"title":"Process & Program","permalink":"/Joseph.github.io/docs/Linux Kernel/Process"}}');var i=r(4848),s=r(8453);const o={},a=void 0,c={},l=[{value:"Brief",id:"brief",level:2},{value:"Stream Buffer Control Block",id:"stream-buffer-control-block",level:2},{value:"Make sure the Control block in a share memory",id:"make-sure-the-control-block-in-a-share-memory",level:2},{value:"First: Casting",id:"first-casting",level:3},{value:"Second: Link-Script with attribute",id:"second-link-script-with-attribute",level:3},{value:"Thed Send &amp; Recv Mechanism about Stream Buffer",id:"thed-send--recv-mechanism-about-stream-buffer",level:2},{value:"Send state diagram",id:"send-state-diagram",level:3},{value:"Recv state diagram",id:"recv-state-diagram",level:3},{value:"The Structure of Cross-core Message Buffer",id:"the-structure-of-cross-core-message-buffer",level:2},{value:"Implement",id:"implement",level:2},{value:"Code we need modified",id:"code-we-need-modified",level:2},{value:"Notify by interrupt",id:"notify-by-interrupt",level:2},{value:"Share Memory for identify the Interrupt event.",id:"share-memory-for-identify-the-interrupt-event",level:2}];function d(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h2,{id:"brief",children:"Brief"}),"\n",(0,i.jsx)(n.admonition,{type:"warning",children:(0,i.jsxs)(n.p,{children:["This Note arrange work flow about:\n",(0,i.jsx)(n.strong,{children:'"How to use FreeRTOS stream buffer build a simple cross core message buffer."'})]})}),"\n",(0,i.jsx)(n.h2,{id:"stream-buffer-control-block",children:"Stream Buffer Control Block"}),"\n",(0,i.jsxs)(n.p,{children:["In FreeRTOS, Stream Buffer use ",(0,i.jsx)(n.code,{children:"StreamBuffer_t"})," type as a control block type, ",(0,i.jsx)(n.strong,{children:'"All of control information will stay in same structure"'}),"."]}),"\n",(0,i.jsxs)(n.admonition,{type:"warning",children:[(0,i.jsxs)(n.p,{children:["This structure only could be access in kernel, because the structure itself define in ",(0,i.jsx)(n.code,{children:".c"})," file not ",(0,i.jsx)(n.code,{children:".h"}),"."]}),(0,i.jsx)(n.p,{children:"The author don't want user directly access task control block."}),(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"So how do we use it or calculate the size of the structure ?"})})]}),"\n",(0,i.jsxs)(n.p,{children:["Define ",(0,i.jsx)(n.a,{href:"https://github.com/FreeRTOS/FreeRTOS-Kernel/blob/0030d609a4b99118d9a400340d88c3c3c4816f2b/stream_buffer.c#L232",children:"FreeRTOS-Kernel/stream_buffer.c"})]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-c=",children:"typedef struct StreamBufferDef_t\n{\n    volatile size_t xTail;                       /* Index to the next item to read within the buffer. */\n    volatile size_t xHead;                       /* Index to the next item to write within the buffer. */\n    size_t xLength;                              /* The length of the buffer pointed to by pucBuffer. */\n    size_t xTriggerLevelBytes;                   /* The number of bytes that must be in the stream buffer before a task that is waiting for data is unblocked. */\n    volatile TaskHandle_t xTaskWaitingToReceive; /* Holds the handle of a task waiting for data, or NULL if no tasks are waiting. */\n    volatile TaskHandle_t xTaskWaitingToSend;    /* Holds the handle of a task waiting to send data to a message buffer that is full. */\n    uint8_t * pucBuffer;                         /* Points to the buffer itself - that is - the RAM that stores the data passed through the buffer. */\n    uint8_t ucFlags;\n\n    #if ( configUSE_TRACE_FACILITY == 1 )\n        UBaseType_t uxStreamBufferNumber; /* Used for tracing purposes. */\n    #endif\n\n    #if ( configUSE_SB_COMPLETED_CALLBACK == 1 )\n        StreamBufferCallbackFunction_t pxSendCompletedCallback;    /* Optional callback called on send complete. sbSEND_COMPLETED is called if this is NULL. */\n        StreamBufferCallbackFunction_t pxReceiveCompletedCallback; /* Optional callback called on receive complete.  sbRECEIVE_COMPLETED is called if this is NULL. */\n    #endif\n    UBaseType_t uxNotificationIndex;                               /* The index we are using for notification, by default tskDEFAULT_INDEX_TO_NOTIFY. */\n} StreamBuffer_t;\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Previous we mention the ",(0,i.jsx)(n.code,{children:"StreamBuffer_t"})," only use in kernel code, so here the ",(0,i.jsx)(n.code,{children:"StaticStreamBuffer_t"}),' provide a way let us could use this "type" get the struct size.']}),"\n",(0,i.jsxs)(n.p,{children:["Like: ",(0,i.jsx)(n.code,{children:"sizeof()"})]}),"\n",(0,i.jsxs)(n.p,{children:["Define: ",(0,i.jsx)(n.a,{href:"https://github.com/FreeRTOS/FreeRTOS-Kernel/blob/0030d609a4b99118d9a400340d88c3c3c4816f2b/include/FreeRTOS.h#L3348",children:"FreeRTOS-Kernel/include/FreeRTOS.h"})]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-c=",children:"typedef struct xSTATIC_STREAM_BUFFER\n{\n    size_t uxDummy1[ 4 ];\n    void * pvDummy2[ 3 ];\n    uint8_t ucDummy3;\n    #if ( configUSE_TRACE_FACILITY == 1 )\n        UBaseType_t uxDummy4;\n    #endif\n    #if ( configUSE_SB_COMPLETED_CALLBACK == 1 )\n        void * pvDummy5[ 2 ];\n    #endif\n    UBaseType_t uxDummy6;\n} StaticStreamBuffer_t;\n"})}),"\n",(0,i.jsx)(n.p,{children:"Right now we already know the structure use to control stream buffer, all of control infomation will stay in it."}),"\n",(0,i.jsxs)(n.admonition,{type:"warning",children:[(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:'"So, first we make sure the object will stay in a share memory that could be accessable from different core."'})}),(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"How to do that ?"})})]}),"\n",(0,i.jsx)(n.h2,{id:"make-sure-the-control-block-in-a-share-memory",children:"Make sure the Control block in a share memory"}),"\n",(0,i.jsx)(n.p,{children:"Here, I have two way for implement it."}),"\n",(0,i.jsx)(n.h3,{id:"first-casting",children:"First: Casting"}),"\n",(0,i.jsx)(n.admonition,{type:"warning",children:(0,i.jsx)(n.p,{children:(0,i.jsxs)(n.strong,{children:["Determined an address and casting the address by ",(0,i.jsx)(n.code,{children:"StreamBufferHandle_t"})," type."]})})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"StreamBufferHandle_t"})," type is a typedef type provide from ",(0,i.jsx)(n.a,{href:"https://github.com/FreeRTOS/FreeRTOS-Kernel/blob/0030d609a4b99118d9a400340d88c3c3c4816f2b/include/stream_buffer.h#L79",children:"FreeRTOS-Kernel/include/stream_buffer.h"}),", it provide a way that us could use it casting an object to the structure."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Second: Link-Script with GNU attribute"})}),"\n",(0,i.jsx)(n.admonition,{type:"success",children:(0,i.jsxs)(n.p,{children:["As we know, the ",(0,i.jsx)(n.strong,{children:'"Link-Script"'})," decided the final mapping between the object we see in code and the physical address, so here we could do this:"]})}),"\n",(0,i.jsx)(n.h3,{id:"second-link-script-with-attribute",children:"Second: Link-Script with attribute"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-=",children:"MEMORY {\n    ...\n    SHARE_MEM: ORIGIN = 0x80000000, LENGTH = 24k\n    ...\n}\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-=",children:".shareMem (NOLOAD) : ALIGN(16) {\n    PROVIDE( __shareMem_start = .);\n    *(.shareMem .shareMem.*)\n    PROVIDE( __shareMem_start = .);\n} >SHARE_MEM\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"C code:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-c",children:'<type> __attribute__(section(".shareMem")) control_block = {\n    .<member> = 0x...,\n};\n'})}),"\n",(0,i.jsxs)(n.p,{children:["Above is an example for demo ",(0,i.jsx)(n.strong,{children:'"how to declare a global variable, let could be access between different core."'})]}),"\n",(0,i.jsxs)(n.admonition,{type:"warning",children:[(0,i.jsxs)(n.p,{children:["If we don't use GNU-attribute told the linker put this variable into the ",(0,i.jsx)(n.code,{children:".shareMem"})," section, by default it will be put into ",(0,i.jsx)(n.code,{children:".data"})," section."]}),(0,i.jsx)(n.p,{children:'Because by usually different core have it own "DLM", when compiler see the variable it will see the variable as a variable that would be put in itself "DLM", but for cross-core communicate, we need the control block share between each core, so the modify will be see by each other, and that is why we need link-script arrange a space and use GNU-attribute told the linker put this variable in the section we want.'}),(0,i.jsx)(n.p,{children:"So the fianl global variable have same name and both use GNU-attribute put it in the section will have same instance."})]}),"\n",(0,i.jsx)(n.h2,{id:"thed-send--recv-mechanism-about-stream-buffer",children:"Thed Send & Recv Mechanism about Stream Buffer"}),"\n",(0,i.jsx)(n.h3,{id:"send-state-diagram",children:"Send state diagram"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-c=",children:" \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n \u2502 Start / Assert\u2502\n \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        \u2502\n        \u25bc\n \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n \u2502 Check Buffer  \u2502\n \u2502 Type          \u2502\n \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        \u2502\n        \u251c\u2500\u2500\u2500[Message Buffer & Too Big]\u2500\u2500\u2500\u25ba (Force xTicksToWait=0)\n        \u2502\n        \u25bc\n \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n \u2502 Wait for Space?   \u2502\u25c4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n \u2502 (xTicksToWait > 0)\u2502                \u2502\n \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                \u2502\n        \u2502Yes                          \u2502 Timeout\n        \u25bc                             \u2502\n \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510            \u2502\n \u2502 Check Available Space \u2502            \u2502\n \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518            \u2502\n        \u2502Enough                       \u2502\n        \u25bc                             \u2502\n \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  Not enough        \u2502\n \u2502 Write to Buf  \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        \u2502\n        \u2502 Success (xReturn > 0)\n        \u25bc\n \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n \u2502 Trigger recv if ready \u2502\n \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        \u2502\n        \u25bc\n  (Return xReturn)\n\n        \u2502``\n        \u2502 Failure (xReturn == 0)\n        \u25bc\n \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n \u2502 Trace Failed  \u2502\n \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        \u25bc\n  (Return 0)\n"})}),"\n",(0,i.jsx)(n.h3,{id:"recv-state-diagram",children:"Recv state diagram"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-c=",children:" \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n \u2502 Start / Assert\u2502\n \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        \u25bc\n \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n \u2502 Decide xBytesToStoreMsgLen\u2502\n \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        \u2502\n        \u25bc\n \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n \u2502 Wait for Data?        \u2502\n \u2502 (xTicksToWait > 0)    \u2502\n \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        \u2502Yes\n        \u25bc\n \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n \u2502 Check Available Bytes     \u2502\n \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        \u2502Enough bytes\n        \u25bc\n \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n \u2502 Read From Buffer          \u2502\n \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        \u2502\n        \u2502 Success\n        \u25bc\n \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n \u2502 Trace + Wake Sender       \u2502\n \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        \u2502\n        \u25bc\n   (Return xReceivedLength)\n\n        \u2502\n        \u2502 Failure (not enough bytes or read=0)\n        \u25bc\n \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n \u2502 Trace Receive Failed      \u2502\n \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        \u25bc\n   (Return 0)\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Basically, when buffer have enough space the send function will put message in buffer and trigger interrupt by ",(0,i.jsx)(n.code,{children:"PLIC"})," signal the other core, if buffer already full or the space dosen't enough, this situation will depend on the timeout you specify, if timeout value unequal to zero, it will waiting until timeout."]}),"\n",(0,i.jsx)(n.p,{children:"Recv same as send."}),"\n",(0,i.jsx)(n.h2,{id:"the-structure-of-cross-core-message-buffer",children:"The Structure of Cross-core Message Buffer"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{src:"https://hackmd.io/_uploads/BJvnfpP5ll.svg",alt:"CtcMessageBuffer.drawio"})}),"\n",(0,i.jsxs)(n.admonition,{type:"success",children:[(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Behavior Description"})}),(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Send"}),":"]}),(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"If Buffer have enough space it will copy message from local memory to share buffer, and trigger interrupt for notify other core receive message."}),"\n",(0,i.jsx)(n.li,{children:"If buffer dosen't have space it will return directly."}),"\n"]}),(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Recv:"})}),(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"If Buffer have message it will copy the message from share buffer to the local buffer you specified."}),"\n",(0,i.jsx)(n.li,{children:"If buffer dosen't have message it will check the timeout value, if it more than zero, it will waiting until timeout, or just return directly."}),"\n"]})]}),"\n",(0,i.jsx)(n.p,{children:"Next we will looking how to implement all of that."}),"\n",(0,i.jsx)(n.h2,{id:"implement",children:"Implement"}),"\n",(0,i.jsx)(n.p,{children:"First, we need list all of problem need solve:"}),"\n",(0,i.jsxs)(n.admonition,{type:"warning",children:[(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Problem we need solve:"})}),(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.strong,{children:'The Buffer Control Block should stay in a "memory region", that could be access from each other core.'})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.strong,{children:"How to notify other core, when data already put in buffer ?"})}),"\n"]})]}),"\n",(0,i.jsx)(n.p,{children:"The first we already told above, so we start from second."}),"\n",(0,i.jsx)(n.h2,{id:"code-we-need-modified",children:"Code we need modified"}),"\n",(0,i.jsxs)(n.p,{children:["According this ",(0,i.jsx)(n.a,{href:"https://www.freertos.org/Community/Blogs/2020/simple-multicore-core-to-core-communication-using-freertos-message-buffers",children:'"post"'})," we know, the key component for ",(0,i.jsx)(n.code,{children:"send"})," & ",(0,i.jsx)(n.code,{children:"receive"})," are ",(0,i.jsx)(n.code,{children:"sbSEND_COMPLETED()"})," & ",(0,i.jsx)(n.code,{children:"sbRECEIVE_COMPLETED()"})," and the FreeRTOS message buffer is base on stream buffer mechanism, so if we search above functions in the source file, we could find:"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"sbSEND_COMPLETED()"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-c",children:"#ifndef sbSEND_COMPLETED\n    #define sbSEND_COMPLETED( pxStreamBuffer )                                  \\\nvTaskSuspendAll();                                                              \\\n{                                                                               \\\n    if( ( pxStreamBuffer )->xTaskWaitingToReceive != NULL )                     \\\n    {                                                                           \\\n        ( void ) xTaskNotifyIndexed( ( pxStreamBuffer )->xTaskWaitingToReceive, \\\n                                     ( pxStreamBuffer )->uxNotificationIndex,   \\\n                                     ( uint32_t ) 0,                            \\\n                                     eNoAction );                               \\\n        ( pxStreamBuffer )->xTaskWaitingToReceive = NULL;                       \\\n    }                                                                           \\\n}                                                                               \\\n( void ) xTaskResumeAll()\n#endif /* sbSEND_COMPLETED */\n\n#if ( configUSE_SB_COMPLETED_CALLBACK == 1 )\n    #define prvSEND_COMPLETED( pxStreamBuffer )                                           \\\ndo {                                                                                      \\\n    if( ( pxStreamBuffer )->pxSendCompletedCallback != NULL )                             \\\n    {                                                                                     \\\n        ( pxStreamBuffer )->pxSendCompletedCallback( ( pxStreamBuffer ), pdFALSE, NULL ); \\\n    }                                                                                     \\\n    else                                                                                  \\\n    {                                                                                     \\\n        sbSEND_COMPLETED( ( pxStreamBuffer ) );                                           \\\n    }                                                                                     \\\n} while( 0 )\n#else /* if ( configUSE_SB_COMPLETED_CALLBACK == 1 ) */\n    #define prvSEND_COMPLETED( pxStreamBuffer )    sbSEND_COMPLETED( ( pxStreamBuffer ) )\n#endif /* if ( configUSE_SB_COMPLETED_CALLBACK == 1 ) */\n"})}),"\n",(0,i.jsxs)(n.p,{children:["If we define ",(0,i.jsx)(n.code,{children:"configUSE_SB_COMPLETED_CALLBACK"})," in ",(0,i.jsx)(n.strong,{children:"FreeRTOSConfig.h"})," it will compile with callback option, but right now we just focue on the general option."]}),"\n",(0,i.jsx)(n.admonition,{type:"warning",children:(0,i.jsxs)(n.p,{children:["Because the original FreeRTOS is use for ",(0,i.jsx)(n.strong,{children:'"single core"'})," processor, it could base on the ",(0,i.jsx)(n.strong,{children:'"notify mechanism"'})," for send signal for the task block by receive function."]})}),"\n",(0,i.jsx)(n.admonition,{type:"warning",children:(0,i.jsxs)(n.p,{children:["\u203c\ufe0f"," But right now in ",(0,i.jsx)(n.strong,{children:'"multi-core" communication'}),", ",(0,i.jsx)(n.strong,{children:'"two tasks are running on the different core and each them manage by separate FreeRTOS kernel"'}),", so we can't use notify mechanism provide by FreeRTOS."]})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Version for Cross-core communication"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-c",children:"#ifndef sbSEND_COMPLETED\n#define sbSEND_COMPLETED( pxStreamBuffer )                                      \\\nvTaskSuspendAll();                                                              \\\n{\n/*\n *  Put PLIC trigger procedure in here ! (On RISC-V)\n */\n}                                                                               \\\n( void ) xTaskResumeAll()\n#endif /* sbSEND_COMPLETED */\n"})}),"\n",(0,i.jsxs)(n.admonition,{type:"warning",children:[(0,i.jsxs)(n.p,{children:["\u81f3\u65bc\uff0c\u662f\u5426\u9700\u8981 ",(0,i.jsx)(n.strong,{children:'"\u66ab\u505c FreeRTOS scheduler"'}),'\uff0c\u6211\u7684\u89c0\u9ede\u662f "\u4e0d\u7528"\u3002']}),(0,i.jsxs)(n.p,{children:["Single-core \u8981\u66ab\u505c\u7684\u539f\u56e0\u5728\u65bc notify mechanism \u6703\u9700\u8981\u4fee\u6539 Task Control Block \u4e2d\u7684\u8cc7\u6599\uff0c\u800c ",(0,i.jsx)(n.code,{children:"vTaskSuspendAll()"})," \u8981\u505a\u7684\u4e8b\u662f ",(0,i.jsx)(n.strong,{children:'"\u78ba\u4fdd\u4fee\u6539\u7684\u539f\u5b50\u6027"'}),"\uff0c\u82e5\u4e0d\u66ab\u505c scheduler\uff0c\u53ef\u80fd\u5c0e\u81f4 Task \u72c0\u614b\u5728\u5207\u63db\u7684\u9014\u4e2d scheduler \u89f8\u767c interrupt \u6253\u65b7\u4fee\u6539\u6d41\u7a0b\uff0c\u9032\u800c\u5c0e\u81f4 Task Control Block \u767c\u751f race condition \u7684\u554f\u984c\u3002"]}),(0,i.jsx)(n.p,{children:"\u8981\u4fdd\u8b77\u7684\u662f\u5728 Share memory \u4e2d\uff0c\u6703\u88ab\u591a\u9846\u6838\u5fc3\u5b58\u53d6\u7684\u8cc7\u6599\u7d50\u69cb\uff0c\u7576\u7136\u9019\u53d6\u6c7a\u65bc\u8a72\u8cc7\u6599\u7d50\u69cb\u7684\u8a2d\u8a08\u3002"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"sbRECEIVE_COMPLETED()"})}),"\n",(0,i.jsx)(n.p,{children:"The idea same as send, skip ~"}),"\n",(0,i.jsx)(n.h2,{id:"notify-by-interrupt",children:"Notify by interrupt"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.strong,{children:'"interrupt structure"'})," will depend on different ",(0,i.jsx)(n.strong,{children:'"ISA"'}),", so in here we will use pseudo code."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"https://github.com/FreeRTOS/FreeRTOS/blob/main/FreeRTOS/Demo/RISC-V_RV32_SiFive_HiFive1-RevB_FreedomStudio/freedom-metal/src/entry.S",children:"entry.S"})}),"\n",(0,i.jsx)(n.p,{children:"\u4ee5 RISC-V PLIC \u70ba\u4f8b \u6703\u900f\u904e \u5c0d Target panding bit \u5beb\u5165 1 \u7522\u751f\u8a72 Target output wire \u6240\u9023\u63a5\u5230\u7684 Core \u7684 MEIP or MSIP\uff1a"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-=",children:"PLIC_Trigger_function()\n"})}),"\n",(0,i.jsx)(n.h2,{id:"share-memory-for-identify-the-interrupt-event",children:"Share Memory for identify the Interrupt event."}),"\n",(0,i.jsx)(n.p,{children:"Interrupt Wire \u5728\u53ea\u6709\u4e00\u689d\u7dda\u7684\u60c5\u6cc1\u4e0b\uff0c\u82e5\u8981\u5c07 FreeRTOS \u4e2d\u7684\u529f\u80fd\u5168\u90e8\u652f\u63f4 Cross-core \u5c31\u9700\u8981\u4e00\u500b\u984d\u5916\u7684 \u201c\u8a0a\u606f\u201d \u4f86\u8868\u793a\u662f \u201c\u8ab0 (Message-buffer\u3001Notify\u3001Queue)\u201d \u7522\u751f\u4e2d\u65b7\u3002"})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>o,x:()=>a});var t=r(6540);const i={},s=t.createContext(i);function o(e){const n=t.useContext(s);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);