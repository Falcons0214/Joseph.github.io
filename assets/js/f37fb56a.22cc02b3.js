"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[833],{3430:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>h,contentTitle:()=>l,default:()=>c,frontMatter:()=>s,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"Column Base DBMS/B-link-tree","title":"B-link-tree","description":"The Storage model","source":"@site/docs/Column Base DBMS/B-link-tree.md","sourceDirName":"Column Base DBMS","slug":"/Column Base DBMS/B-link-tree","permalink":"/Joseph.github.io/docs/Column Base DBMS/B-link-tree","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/Column Base DBMS/B-link-tree.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","next":{"title":"System Design","permalink":"/Joseph.github.io/docs/Column Base DBMS/System Design"}}');var o=t(4848),r=t(8453);const s={},l=void 0,h={},d=[{value:"The Storage model",id:"the-storage-model",level:2},{value:"Some Notation we need know",id:"some-notation-we-need-know",level:2},{value:"The Data Structure",id:"the-data-structure",level:2},{value:"Structure",id:"structure",level:3},{value:"Sequence",id:"sequence",level:3},{value:"Insertion Rule",id:"insertion-rule",level:3},{value:"Delete Rule",id:"delete-rule",level:3},{value:"Approache without link",id:"approache-without-link",level:2},{value:"B_link_tree for Concurrency",id:"b_link_tree-for-concurrency",level:2},{value:"About the &quot;link&quot;",id:"about-the-link",level:3},{value:"Purpose of the &quot;link&quot;",id:"purpose-of-the-link",level:3},{value:"Search Algorithm for B_link_tree",id:"search-algorithm-for-b_link_tree",level:2},{value:"Algorithm Sketch",id:"algorithm-sketch",level:3},{value:"The Algorithm",id:"the-algorithm",level:3},{value:"Insertion Algorithm for B_link_tree",id:"insertion-algorithm-for-b_link_tree",level:2},{value:"Algorithm Sketch",id:"algorithm-sketch-1",level:3},{value:"The Algorithm",id:"the-algorithm-1",level:3}];function a(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.h2,{id:"the-storage-model",children:"The Storage model"}),"\n",(0,o.jsxs)(n.admonition,{type:"info",children:[(0,o.jsxs)(n.p,{children:["The disk is partitioned into sections of a fixed size\u201c(physical pages; ",(0,o.jsx)(n.strong,{children:"in this paper, these will correspond to logical nodes of the tree)."})]}),(0,o.jsx)(n.p,{children:"These are the only units that can be read or written by a process. Further, a process is considered to have a fixed amount of primary memory at its disposal, and can therefore only examine a fixed number of pages simultaneously."}),(0,o.jsx)(n.p,{children:"This primary memory is not shared with other processes."})]}),"\n",(0,o.jsx)(n.h2,{id:"some-notation-we-need-know",children:"Some Notation we need know"}),"\n",(0,o.jsxs)(n.admonition,{type:"info",children:[(0,o.jsx)(n.p,{children:"Lowercase symbols (x, t, current, etc.) are used to refer to variables (including pointers) in the primary storage of a process."}),(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Uppercase symbols (A, B, C) are used to refer to blocks of primary storage."})," It is these blocks which are used by the process for reading and writing pages on the disk."]})]}),"\n",(0,o.jsx)(n.admonition,{type:"info",children:(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"lock(x)"})," denotes the operation of locking the disk page to which x points. If the page is already locked by another process, the operation waits until it is possible to obtain the lock."]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"unlock(x)"})," similarly denotes the operation of releasing a held lock."]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"A get(x)"})," denotes the operation of reading into memory block A, the contents of the disk page to which x points. (\u5c07page\u8f09\u5165\u81f3\u8a18\u61b6\u9ad4)"]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"put(A, x)"})," similarly denotes the operation of writing onto the page to which x points, the contents of memory block A. The procedures must enforce the restriction that a process must hold the lock for that page before performing this operation. (\u5c07page\u5beb\u56de\u81f3\u786c\u789f)"]}),"\n"]}),"\n"]})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.img,{src:"https://hackmd.io/_uploads/ry7lBeqO3.png",alt:""})}),"\n",(0,o.jsx)(n.h2,{id:"the-data-structure",children:"The Data Structure"}),"\n",(0,o.jsx)(n.p,{children:"\u9019\u908a\u90fd\u662f\u5c0d\u5c07\u8981\u4f7f\u7528\u7684 B-Tree \u7684\u5b9a\u7fa9"}),"\n",(0,o.jsx)(n.h3,{id:"structure",children:"Structure"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.img,{src:"https://hackmd.io/_uploads/rkuTBl5uh.png",alt:""})}),"\n",(0,o.jsx)(n.admonition,{type:"info",children:(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Each path from the root to any leaf has the same length, h."}),"\n",(0,o.jsx)(n.li,{children:"The root is a leaf or has at least two sons."}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.strong,{children:"Each node has at most 2k + 1 sons."})}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsxs)(n.strong,{children:[(0,o.jsx)(n.em,{children:"The keys for all of the data in the B"}),"-tree are stored in the leaf nodes, which also contain pointers to the records of the database."]})," (Each record is associated with a key.) Nonleaf nodes contain pointers and the key values to be used in following those pointers."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Each node except the root and the leaves has at least k + 1 sons."})," (k is a tree parameter; 2k is the maximum number of elements in a node, neglecting the \u201chigh key,\u201d which is explained below.)"]}),"\n"]})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Example:"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.img,{src:"https://hackmd.io/_uploads/HJRZvlnd3.png",alt:""})}),"\n",(0,o.jsx)(n.p,{children:"\u4e0a\u5716 \u201cK(i)\u201d are instances of the key domain, \u201cP(i)\u201d \u5728internel node\u70ba\u6307\u5411 node \u7684\u6307\u6a19\uff0c\u5728 leaf node\u70ba\u6307\u5411\u8cc7\u6599\u7684\u6307\u6a19\u3002"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.img,{src:"https://hackmd.io/_uploads/rJ_jdl5d2.png",alt:""})}),"\n",(0,o.jsx)(n.admonition,{type:"info",children:(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:'"M" is a marker that indicates a leaf node and occupies the same position as the first pointer in a nonleaf node.'})})}),"\n",(0,o.jsx)(n.h3,{id:"sequence",children:"Sequence"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.img,{src:"https://hackmd.io/_uploads/BJcxNQod2.png",alt:""})}),"\n",(0,o.jsx)(n.admonition,{type:"info",children:(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Within each node, the keys are in ascending order."}),"\n",(0,o.jsxs)(n.li,{children:["In the B*-tree an additional value, called the ",(0,o.jsx)(n.strong,{children:"\u201chigh key,\u201d"})," is sometimes appended to nonleaf nodes (Figure 3)."]}),"\n"]})}),"\n",(0,o.jsxs)(n.p,{children:["\u9019\u908a\u7684 ",(0,o.jsx)(n.strong,{children:"\u201chigh key\u201d"})," \u5c31\u662f\u4ee5\u6b64 \u201chigh key\u201d \u6240\u5728\u7684\u7bc0\u9ede\u70baroot\u7684\u5b50\u6a39\u7684upper-bound\u3002"]}),"\n",(0,o.jsx)(n.h3,{id:"insertion-rule",children:"Insertion Rule"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.img,{src:"https://hackmd.io/_uploads/SyErUQs_2.png",alt:""})}),"\n",(0,o.jsxs)(n.admonition,{type:"warning",children:[(0,o.jsx)(n.p,{children:"\u6ce8\u610f \uff01\uff01"}),(0,o.jsxs)(n.p,{children:["\u4e0a\u5716\u4e2d\u63d2\u5165\u524d ",(0,o.jsx)(n.strong,{children:"\u5728leaf node\u768474\u662fhigh key\u4e26\u4e0d\u662fentry"})]})]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Rule 1: ( < 2k)"})}),"\n",(0,o.jsx)(n.admonition,{type:"info",children:(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"If a leaf node has fewer than 2k entries"}),", then a new entry and the pointer to the associated record are ",(0,o.jsx)(n.strong,{children:"simply inserted into the node."})]})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Rule 2: ( == 2k)"})}),"\n",(0,o.jsxs)(n.admonition,{type:"info",children:[(0,o.jsxs)(n.p,{children:["If a ",(0,o.jsx)(n.strong,{children:"leaf has 2k entries"}),", then the new entry is inserted by splitting the node into two nodes, each with half ofthe entries from the old node."]}),(0,o.jsxs)(n.p,{children:["More specifically, ",(0,o.jsx)(n.strong,{children:"when splitting node a into a\u2019 and b\u2019, the (new) high key for node a\u2019 is inserted into the parent node."})," The high key for node b\u2019 is the same as the old high key for a. A new pointer to b is also inserted."]})]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Rule 3 (when node is inter-node)"})}),"\n",(0,o.jsx)(n.admonition,{type:"info",children:(0,o.jsx)(n.p,{children:"Insertion into nonleaf nodes proceeds identically, except that the pointers point to son nodes, rather than to data records."})}),"\n",(0,o.jsx)(n.h3,{id:"delete-rule",children:"Delete Rule"}),"\n",(0,o.jsxs)(n.p,{children:["\u9019\u908a\u8ad6\u6587\u4e26\u6c92\u6709\u63d0\u5230\u522a\u9664\u7684\u89e3\u6cd5\u6703\u53c3\u8003\u9019\u7bc7: ",(0,o.jsx)(n.a,{href:"https://dl.acm.org/doi/pdf/10.5555/324493.324589",children:"A SYMMETRIC CONCURRENT B-TREE ALGORITHM"})]}),"\n",(0,o.jsx)(n.h2,{id:"approache-without-link",children:"Approache without link"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.img,{src:"https://hackmd.io/_uploads/Sy5EwvH9n.png",alt:""})}),"\n",(0,o.jsxs)(n.p,{children:["\u9019\u908a\u900f\u904e\u4e00\u500b\u7c21\u55ae\u7684\u7bc4\u4f8b\u6f14\u793a\u7576 ",(0,o.jsx)(n.code,{children:"search()"})," \u8207 ",(0,o.jsx)(n.code,{children:"insert()"})," \u4e26\u884c\u6642\u6703\u767c\u751f\u5f97\u7684\u554f\u984c\u3002"]}),"\n",(0,o.jsx)(n.admonition,{type:"info",children:(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Consider the B-tree segment shown in Figure 5a. Suppose we have two processes: a search for the value 15 and an insertion of the value 9. The insertion should cause the modification to the tree structure shown in Figure 5b."})})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Now consider the following sequence of operations:"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.img,{src:"https://hackmd.io/_uploads/SyLxuDrqh.png",alt:""})}),"\n",(0,o.jsxs)(n.p,{children:["\u4e0d\u96e3\u770b\u51fa\uff0c\u5982\u679c\u7a0b\u5f0f\u4f9d\u7167\u4e0a\u8ff0\u9806\u5e8f\u904b\u4f5c\uff0c",(0,o.jsx)(n.code,{children:"search()"}),"\u6703\u767c\u751f\u932f\u8aa4\uff0c\u539f\u56e0\u5728\u65bc",(0,o.jsx)(n.code,{children:"search()"}),"\u5728\u53d6\u5f97 y node \u6642\uff0c",(0,o.jsx)(n.code,{children:"15"})," \u4ecd\u7136\u5b58\u5728\u8a72\u7bc0\u9ede\u4e2d\uff0c\u4f46 ",(0,o.jsx)(n.code,{children:"insert()"})," \u64cd\u4f5c\u767c\u751f\u5f8c\u9054\u6210 node \u5206\u88c2\u7684\u689d\u4ef6\uff0c\u800c ",(0,o.jsx)(n.code,{children:"15"})," \u525b\u597d\u5927\u65bc\u5206\u88c2\u9ede\u9032\u800c\u5c0e\u81f4\u51fa\u932f\u3002"]}),"\n",(0,o.jsx)(n.h2,{id:"b_link_tree-for-concurrency",children:"B_link_tree for Concurrency"}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Node structure"}),"\n",(0,o.jsx)(n.img,{src:"https://hackmd.io/_uploads/BkkdCXjO3.png",alt:""})]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"The B-link-tree is a B-tree modified by adding a single \u201clink\u201d pointer field to each\nnode (P2k+1 - see Figure 6)."})}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Tree structure"}),"\n",(0,o.jsx)(n.img,{src:"https://hackmd.io/_uploads/Bk1q5e2dh.png",alt:""})]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"\u53ef\u4ee5\u7406\u89e3\u6210\uff0c\u5728\u540c\u4e00 level \u7684\u7bc0\u9ede\u5f9e\u5de6\u5230\u53f3\u5c31\u50cf link-list\u822c\u9023\u63a5\u8457"})}),"\n",(0,o.jsx)(n.h3,{id:"about-the-link",children:'About the "link"'}),"\n",(0,o.jsxs)(n.admonition,{type:"info",children:[(0,o.jsxs)(n.p,{children:["This ",(0,o.jsx)(n.strong,{children:"link field points to the next node at the same level of the tree as the current node"}),", except that the link pointer of the rightmost node on a level is a null pointer."]}),(0,o.jsx)(n.p,{children:"This definition for link pointers is consistent, since all leaf nodes lie at the same level of the tree. The B-link-tree has all of the nodes at a particular level chained together into a linked list, as illustrated in Figure 7."})]}),"\n",(0,o.jsx)(n.h3,{id:"purpose-of-the-link",children:'Purpose of the "link"'}),"\n",(0,o.jsxs)(n.admonition,{type:"info",children:[(0,o.jsxs)(n.p,{children:["Is to ",(0,o.jsx)(n.strong,{children:"provide an additional method for reaching a node."})," When a node is split because of data overflow, a single node is replaced by two new node."]}),(0,o.jsx)(n.p,{children:"When a node is split because of data overflow, a single node is replaced by two new node. The link pointer of the first new node points to the second node; the link pointer of the second node contains the old contents of the link pointer field of the first node."}),(0,o.jsxs)(n.p,{children:["Usually, the ",(0,o.jsx)(n.strong,{children:"first new node occupies the same physical page"})," on the disk as the old single node."]})]}),"\n",(0,o.jsx)(n.h2,{id:"search-algorithm-for-b_link_tree",children:"Search Algorithm for B_link_tree"}),"\n",(0,o.jsx)(n.h3,{id:"algorithm-sketch",children:"Algorithm Sketch"}),"\n",(0,o.jsxs)(n.admonition,{type:"info",children:[(0,o.jsxs)(n.p,{children:["If the search process examines a node and finds that ",(0,o.jsxs)(n.strong,{children:["the maximum value given by that node is less than ",(0,o.jsx)(n.code,{children:"u"}),", then it infers some change has taken place in the current node"]})," that had not been indicated in the father at the time the father was examined by the search."]}),(0,o.jsxs)(n.p,{children:["The current node must have been split into two (or more) new nodes. ",(0,o.jsx)(n.strong,{children:"The search must then rectify the error in its position in the tree by following the link pointer of the newly split node instead of by following a son pointer"})," as it would ordinarily do."]})]}),"\n",(0,o.jsxs)(n.p,{children:["\u6839\u64da\u4e0a\u8ff0\u5b9a\u7fa9\uff0c\u53ef\u4ee5\u78ba\u5b9a\u8981\u641c\u5c0b\u7684\u67d0\u4e00\u503c ",(0,o.jsx)(n.code,{children:"u"})," \u5728\u8207\u4efb\u4f55\u7bc0\u9ede\u4e2d\u5b58\u5728\u7684\u503c\u505a\u6bd4\u8f03\u6642\uff0c\u4e0d\u6703\u8d85\u904e\u8a72\u7bc0\u9ede\u7684\u6700\u5927\u503c\uff0c\u5982\u679c\u8d85\u51fa\u5c31\u53ef\u4ee5\u78ba\u5b9a\u518d\u641c\u5c0b\u6642\u8a72\u7bc0\u9ede\u767c\u751f\u5206\u88c2\uff0c\u9019\u6642\u5c31\u4e0d\u8a72\u518d\u5f80\u4e0b\u5c64(\u5b50\u7bc0\u9ede)\u8d70\uff0c\u800c\u662f\u900f\u904e right-link \u5c0b\u8a2a\u5230\u7b26\u5408\u5b9a\u7fa9\u7684\u7bc0\u9ede\u518d\u7e7c\u7e8c\u5c0b\u8a2a\u5411\u4e0b\u81f3\u8449\u5b50\u7bc0\u9ede\u3002"]}),"\n",(0,o.jsx)(n.h3,{id:"the-algorithm",children:"The Algorithm"}),"\n",(0,o.jsx)(n.admonition,{type:"info",children:(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"x scannode(u, A):"})," denotes the operation of examining the tree node in memory block A for value u and returning the appropriate pointer from A (into x)."]}),"\n"]})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-c",children:"procedure search(u)\n    \ncurrent = root; /* Get ptr to root node */\n\nA = get(current); /* Read node into memory */\n\nwhile current is not a leaf do /* Scan through tree */\nbegin \n    current = scannode(u, A); /* Find correct (maybe link) ptr */\n    A = get(current)          /* Read node into memory */  \nend; \n\n/* Now we have reached leaves. */\n\nwhile (t = scannode(u, A)) == link ptr of A do\n    /* Keep moving right if necessary */ \nbegin \n    current = t ; \n    A = get(current) /* Get node */\nend;\n\n/* Now we have the leaf node in which u should exist. */\n\nif v is in A then done \u201csuccess\u201d else done \u201cfailure\u201d \n"})}),"\n",(0,o.jsx)(n.h2,{id:"insertion-algorithm-for-b_link_tree",children:"Insertion Algorithm for B_link_tree"}),"\n",(0,o.jsx)(n.h3,{id:"algorithm-sketch-1",children:"Algorithm Sketch"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.img,{src:"https://hackmd.io/_uploads/H18zwz853.png",alt:""})}),"\n",(0,o.jsx)(n.h3,{id:"the-algorithm-1",children:"The Algorithm"}),"\n",(0,o.jsx)(n.admonition,{type:"info",children:(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"A  node.insert (A, w, u):"})," denotes the operation of inserting the pointer w and the value u into the node contained in A."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"u  allocate(2 newpage for B):"})," denotes the operation of allocating a new page on the disk. The node contained in B will be written onto this page, using the pointer u."]}),"\n"]})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-c",children:"procedure insert(v)\n    \ninitialize stack; /* For remembering ancestors */\n\ncurrent = root; \nA = get(current); \n \nwhile current is not a leaf do /* Scan down tree */\nbegin \n    t = current; \n    current = scannode(v, A); \n    if new current was not link pointer in A then \n        push(t);     /* Remember node at that level */\n    A = get(current) \nend; \n\nlock(current); /* We have a candidate leaf */\nA = get(current); \nmove.right; /* If necessary */\n\nif v is in A then stop \u201cv already exists in tree\u201d /* And t points to its record */ \nw = pointer to pages allocated for record associated with v; \n\nDoinsertion:\nif A is safe then \nbegin \n    A = node.insert(A, w, v); /* Exact manner depends if current is a leaf */\n    put(A, current); \n    unLock(current); /* Success-done backtracking */\nend else begin       /* Must split node */\n    u = allocate(1 new page for B); \n    A, B = rearrange old A, adding v and w, to make 2 nodes, \n        where (link ptr of A, link ptr of B) = (u, link ptr of old A); \n    y = max value stored in new A; /* For insertion into parent */\n    put(B, u); /* Insert B before A */\n    put(A, current); /* Instantaneous change of 2 nodes */\n    \n    /* Now insert pointer in parent */\n    oldnode = current;\n    v = y; \n    w = u; \n    current = pop(stack); /* Backtrack */\n    lock(current); /* WeII ordered */\n    A = get(current); \n    move.right; /* If necessary */\n    unlock(oldnode); \n    goto Doinsertion /* And repeat procedure for parent */ \nend;\n\n/* Move.right. This procedure, which is called by insert,\n   follows link pointers at a given level, if necessary. */   \nprocedure move.right \nwhile (t = scannode(u, A)) is a link pointer of A do \nbegin         /* Move right if necessary */\n    lock(t);  /* Note left-to-right locking */\n    unlock(current); \n    current = t; \n    A = get(current); \nend;\n"})})]})}function c(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(a,{...e})}):a(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>l});var i=t(6540);const o={},r=i.createContext(o);function s(e){const n=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);